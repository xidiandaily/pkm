GDB 调试工具常用技巧
作者:chiyl
Last update:%%mtime(%c)

%!includeconf:config.t2t

---------------------
%!include: file_head.t2t
---------------------
%!include: change_log.t2t

+介绍+
    gdb 是 GNU 开源组织发布的一个强大的 UNIX 下调试程序的工具。我们在开发程序的时候如果善于利用，会大大减轻我们开发过程中查找bug的工作量。@@
    一般来说，GDB 可以有以下几个好处：
    - 能设定启动参数启动（在调试程序初始化阶段的bug比较有用）。
    - 能方便设置断点（包括条件断点，数据断点），信号断点。
    - 能改变程序运行时的内存值。
    - 程序因断点停止时，可以查看程序当前的调用堆栈，可以选择堆栈中的某一个栈帧进行查看**栈帧中的局部变量，全局变量，静态变量**(**杀手级功能**)。
    - 程序因断点停止时，可以调用程序中的某些函数，来进行特殊操作，例如事件驱动的程序失能时，可以使用这个功能输出用户的log等信息(**杀手级功能**)。
    - 可以调试程序 core 后的文件，查看程序挂掉时的调用堆栈，选择堆栈中的某个栈帧进行查看**栈帧中的局部变量，全局变量，静态变量**（**杀手级功能**）。
    - 可以设置**观察点** ，程序运行经过观察点时，能够自动搜集**用户地定义的数据**，而不停止执行程序。使得一些实时性的操作可以在事后分析，避免因调试影响正确性（**杀手级功能**）。


+启动+
@@
（**因为程序调试时有可能想查看到程序的某些局部变量等，因此在程序编译时请先关闭编译优化选项，查找起来更加方便**）@@

|| 使用例句 | 说明  ||
| gdb <program> | <program> 为执行文件，这是导入将要执行执行的程序，需要执行是使用 r <argv> 命令运行 |
| gdb <program> core | 使用gdb 查看程序生成的core文件，因为程序在执行时不会导入程序文件中的符号表等信息，因此需要带着<program>启动（从中获取符号表） |
| gdb <program> <PID> | gdb 抓取正在运行的程序，<program> 的作用在这里和调试core一样。 |
| gdb | 启动 gdb 调试器，在运行 gdb 之后，在使用 r <program> <argv> 或者 attach <PID> 来启动或抓取正在运行的程序 |


```
  在 GDB 中调试运行的程序
  - 使用 ps 查看到 PID 之后，再用 gdb<program> PID进行挂载
  - 使用 gdb<program> 关联上源码，再用 attach<PID> 进行挂载；使用detach取消挂载;
```

**注意程序运行时，是没有加载程序文件中的符号表等信息的，因此在调用attach时，需要先挂上可执行文件，再 attach。gdb 为了更加使用便捷，如果没有挂载可执行文件，调用attach时，先在当前路径下查找源文件，造成不需要挂载源文件的假象**

 
+断点+

调试程序中，暂停进程运行时必须的，GDB 可以方便的暂停程序的运行。你可以设置程序在哪停住，在什么条件下停住，在收到什么信号时停住等等。你便于你查看运行的变量，以及运行时的流程。@@
当进程被gdb 停住时，你可以使用 info program 来查看程序是否在运行、进程号、被暂停的原因。@@
在gdb 中，我们可以有以下几种暂停方式：断点（breakpoint）、观察点（watchpoint）、捕捉点（catchpoint）、信号（signals）、线程停止（thread stops）。如果要恢复程序运行，可以使用c 或者continue 命令。@@

|| 使用例句 | 说明 |
| break ``[LOCATION] [thread THREADNUM] [if CONDITION]`` | LOCATION：函数名称/文件中的行号/*address地址; THREADNUM: info threads 中的编号; CONDITION: 布尔表达式 |
| rbreak [regex] | 在所有匹配正则表达式的函数上设置无条件断点。设置的断点和使用 break 设置的一样。 regex 的语法和 grep 中的一样 | 
| b make_<按 TAB 键> | 自动补全并列出所有以 make_ 开头的函数(含重载) |
| info b | 打印出当前设置的断点信息 |
| del <NUM> | 删除设置的断点(info b 中的序号) |
| disable<NUM>[range] | 暂时忽略该断点 |
| enable<NUM>[range] | 恢复该断点 |


**数据断点**@@
  当一个表达式改变时，可以用监视点来中断程序运行，而不需要预先知道表达式在哪里发生变化。表达式可以简单如单个某个变量的值，也可以复杂如多个变量用操作符结合起来。@@
  例如：@@
  - 单个变量值的引用
  - 将某个地址转成一个恰当的数据类型。比如 "*(int *)0x12345678" 会在指定地址上件事一个4字节场的区域（64位系统件事8字节）
  - 任意复杂的表达式，例如 ‘a*b + c/d ’。表达式可以程序语言的任何正确的操作符。

|| 使用例句 | 说明 ||
| watch expr [threadnum] | 当表达式 expr 被改变或值改变时 gdb 会中断程序 |
| rwatch expr [threadnum] | 当表达式 expr 的值被读时 gdb 会中断程序 |
| awatch expr [threadnum] | 当表达式 expr 的值被读/写时 gdb 会中断程序 |
| info watchpoints | 打印出监视点，断点和捕获点列表 |

+调试+

|| 使用例句 | 说明 ||
| c/fg [ingnore-count] | 断点后恢复执行程序,直至下个（n个）断点 |
| step<count> | 单步跟踪,会步入带调试信息的函数 |
| next<count> | 单步跟踪,**不会**步入带调试信息的函数 |
| set step-mode on/off | 单步跟踪是，打开/关闭 调试没有debug信息的函数 |
| finish | 运行程序，直到当前函数完成返回，并打印返回堆栈地址及返回值 |
| until | 运行程序直到退出循环体 |
| stepi(si)/nexti(ni) | 单步跟踪一条机器指令 |
| *(TYPE *)0x12345678 | **将指定的地址以 TYPE 的类型进行解析** 在解析 core 时候，对于一些仅仅知道地址，而不能使用正常方法打印的结构（体）可以使用这种办法 |
| print [/f] exr | 查看表达式的值， /f 是要查看的格式（x:十六进制 d:但符号整数 u:无符号整型 o:八进制整型 t:二进制） |
| x /nfu addr | 以 f 格式产看 n 个长度的 addr 地址指向的数据单元，数据单元大小为 u: b:字节 h:二字节 w:四字节 g:八字节 |

+跟踪点+

在程序的某些地方设立跟踪点，当程序运行时经过这些跟踪点的时候，就记录所需要的数据（这些数据由用户确定），但是不停止执行程序。避免因为长时间的中断程序的执行导致程序正确性无法保证。@@
**注意，跟踪点需要 gdb 运行在远程调试的模式下才能使用** @@
使用场景描述如下： @@
（目标机：需要自动抓取数据的程序所在的主机  调试机：gdb所在的机器 **调试机 目标机可以为同一台机器**）@@
  + 目标机上运行 gdbserver [ip]:port file[PID] ，如果是目标机和调试及是同一台机器，则不需要ip，但是端口及端口前面的冒号必须要
  + 调试机上运行 gdb，执行 gdb remote [ip]:port ，连接上目标机。此时gdb 需要你导入可执行文件（因为gdb需要知道符号表），使用 file filename 导入即可
  + trace 设置观察点，设置的方式和设置断点差不多。
  + actions：collect 命令设置程序运行到观察点时，搜集的数据内容。
  + info tracepoints 查看观察点信息
  + tstart 开始观测
  + 目标机执行程序，跑...
  + tstop 停止观测（或者gdb缓冲区满，自动停止）
  + tfind [n] ，选择记录下来的第 n 帧数据（每次经过观察点时记录的数据作为一帧）。
  + print x 以及其他方式打印你所搜集的数据内容。也可以通过脚本自动数据数据内容(tfind 如果不带参数，会自动选择下一帧， gdb 提供 $trace_frame 变量作为本帧编号)
  + tdump 全部显示本帧所抓取到的所有的数据
  + save-tracepoints filename 将当前所有跟踪点的定义及操作等保存到 filename 里面


+寄存器及硬件相关+

  在表达式里可以引用系统寄存器内容，将在寄存器名前置$符作为变量来用。寄存器名对各个系统可能不一样，使用 info registers 可以查看系统的寄存器名。@@


|| 使用例句 | 说明 ||
| info registers | 打印所有寄存器名和值，除了浮点和向量寄存器（在选定的堆栈帧里） |
| info all-registers | 打印所有的寄存器名和值，包括浮点和向量寄存器（在选定堆栈帧里） |
| print $xmml | 对于现代的 X86 架构的寄存器 MMX （奔腾4引入，用于提高浮点数运算速度），里面的数据格式比较特殊，gdb以结构体形式展示 |
| info float | 显示当前框架的浮点单元的硬件相关信息 |
| info vector | 显示向量单元的信息。 |
| info udot | 显示gdb和操作系统通讯的数据结构 struct user 的内容 |
| info mem | 打印所有定义的内存区域列表，每个列表都有:内存模块ID，激活标记，内存区域最低地址，内存区域最高地址，内存区域的属性集 |

+抓取保存内存之中的数据+

|| 使用例句 | 说明 ||
| dump [format] memory filename start_addr end_addr | 将内存从 start_addr 开始到 end_addr 的内存以指定格式转存到文件 |
| dump [format] value filename expr | 将表达式 expr 的值，以指定格式转存到文件 |
| append [binary] memory filename start_addr end_addr | 将值附加到文件（仅支持二级制格式） |
| restore filename [binary] bias start end | 从文件 filename 的内容恢复到内存中。restore能自动识别任何已知的BFD文件，除了原始二进制数据。 |
| generate-core_file [file] | 主动生成一个core文件 （自拍照技术啊） |


+后记+
 
```
 tips: 在开发过程之只需要知道 gdb 可以提供这些功能，如果日后调试时需要具体用到，也可以再 google 之
```
   参考书目：
   + 《Debugging With GDB中文版（带目录）.pdf》
   + 《linux下GDB教程.pdf》

---------------------
%!include: file_head.t2t
